# -*- coding: utf-8 -*-
"""Restaurant_Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yn4PljP6Qdnm18pZhy3rK7ccGWbuA0e7

Level 1: Data Exploration & Descriptive Analysis

Task 1: Data Exploration and Preprocessing
"""

import numpy as np
import pandas as pd

path = '/content/Dataset .csv'
df = pd.read_csv(path)
print("Total Restaurant: ", len(df))
print("Toatal Rows & Columns: ", df.shape)
df.head(5)

df.info()

df.describe()

df.dtypes

"""Data Cleaning"""

df.isnull().sum()

# Clean Columns
def clean_dataframe(df):
  def clean_column(col):
    if col.dtype == 'object':
      # Strip whitespace and replace empty strings with NaN
      return col.str.strip().replace('', np.nan)
    elif pd.api.types.is_numeric_dtype(col):
      # Replace infinite values with NaN
      return col.replace([np.inf, -np.inf], np.nan)
    else:
      return col  # Leave other types untouched (e.g., datetime, bool)

  return df.apply(clean_column)
df = clean_dataframe(df)

"""Check Duplication"""

df[df.duplicated()]

df.drop_duplicates(inplace=True)

df.isnull().sum()

df['Cuisines'].isnull().sum()

missing_cuisines = df[df['Cuisines'].isna()]
print(missing_cuisines[['Restaurant ID', 'Cuisines']])

df['Cuisines'] = df.groupby('Locality')['Cuisines'].transform(
    lambda x: x.fillna(x.mode()[0] if not x.mode().empty else 'Unknown')
)
print("Missing after fill:", df['Cuisines'].sum())

df['Cuisines'].isnull().sum()

top_cuisines = df.groupby('Locality')['Cuisines'].agg(lambda x: x.mode()[0])
print(top_cuisines.head(10))

"""Exploratory Data Analysis (EDA)"""

import seaborn as sns
import matplotlib.pyplot as plt

# Count top 10 cuisines
top_cuisines = df['Cuisines'].value_counts().head(10)

# Plot pie chart
plt.figure(figsize=(8, 8))
plt.pie(top_cuisines.values, labels=top_cuisines.index, autopct='%1.1f%%')
plt.title('Top 10 Cuisines Distribution')
plt.xlabel('Cuisines')
plt.ylabel('Percentage')
plt.axis('equal')
plt.savefig('Cuisines_Distribution.png')
plt.show()

top_cuisines.plot(kind='bar', figsize=(10, 6))
plt.title('Top Cuisines by Locality')
plt.xlabel('Cuisines')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.savefig('Top_Cuisines_by_Locality.png')
plt.show()

# Check data types
print("Data types:\n ", df.dtypes)

"""Data Conversion"""

# Convert 'Average Cost for two' int into float
df['Average Cost for two'] = df['Average Cost for two'].astype(float)

"""Analyze Target Variable"""

# Summary Statistics
print("Summary Statistics:\n", df['Aggregate rating'].describe())

# Value Count
print("Rating distribution:\n", df['Aggregate rating'].value_counts().sort_index())

plt.figure(figsize=(10, 6))
sns.histplot(df['Aggregate rating'], bins=20, kde=True)
plt.title('Distribution of Aggregate Rating')
plt.xlabel('Aggregate Rating')
plt.ylabel('Frequency')
plt.savefig('Aggregate_Rating_Distribution.png')
plt.show()

"""Class Imbalance Check"""

# Convert Rating to Categories
def rating_category(rating):
    if rating >= 4.5:
        return 'Excellent'
    elif rating >= 3.5:
        return 'Good'
    elif rating >= 2.5:
        return 'Average'
    else:
        return 'Poor'

df['Rating Category'] = df['Aggregate rating'].apply(rating_category)

# Check class balance
class_balance = df['Rating Category'].value_counts()
print("Class Balance:\n", class_balance)

class_balance.to_excel('Class_Balance.xlsx')

sns.countplot(x='Rating Category', data=df)
plt.title('Rating Category Distribution')
plt.xlabel('Rating Category')
plt.ylabel('Count')
plt.savefig('Rating_Category_Distribution.png')
plt.show()

"""Task 2: Descriptive Analysis

Basic Statistical Measures for Numerical Columns
"""

# Basic statistics
numerical_cols = ['Average Cost for two', 'Price range', 'Aggregate rating', 'Votes']
stats = df[numerical_cols].describe().T
print("Basic Statistics:\n", stats)

stats.to_excel('Basic_Statistics.xlsx')

"""Numerical Statistics"""

# Histograms
plt.figure(figsize=(12, 8))
for i, col in enumerate(numerical_cols):
    plt.subplot(2, 2, i+1)
    sns.histplot(df[col], kde=True, bins=30)
    plt.title(f'Distribution of {col}')
plt.tight_layout()
plt.savefig('Numerical_Distributions.png')
plt.show()

"""Map Country Codes and Explore Categorical Distributions"""

# Map country codes
country_map = {
    1: 'India', 14: 'Australia', 30: 'Brazil', 37: 'Canada',
    94: 'Indonesia', 148: 'New Zealand', 162: 'Philippines',
    166: 'Qatar', 184: 'Singapore', 189: 'South Africa',
    191: 'Sri Lanka', 208: 'Turkey', 214: 'UAE',
    215: 'United Kingdom', 216: 'United States'
}
df['Country'] = df['Country Code'].map(country_map)

# Categorical distributions
print("Country Distribution:\n", df['Country'].value_counts())
print("City Distribution:\n", df['City'].value_counts().head(10))
print("Cuisine Distribution:\n", df['Cuisines'].value_counts().head(10))

"""Top Cities and Cuisines by Restaurant Count"""

# Top cities
top_cities = df['City'].value_counts().head(10)
print("Top Cities:\n", top_cities)

# Top cuisines
top_cuisines = df['Cuisines'].value_counts().head(10)
print("Top Cuisines:\n", top_cuisines)

"""Country & City Distribution"""

# Country distribution
plt.figure(figsize=(10, 5))
country_counts = df['Country'].value_counts()
sns.barplot(x=country_counts.index, y=country_counts.values)
plt.xticks(rotation=45)
plt.title('Restaurant Count by Country')
plt.ylabel('Count')
plt.savefig('Country_Distribution.png')
plt.show()

# City distribution
plt.figure(figsize=(10, 5))
top_cities = df['City'].value_counts().head(10)
sns.barplot(x=top_cities.index, y=top_cities.values)
plt.xticks(rotation=45)
plt.title('Top 10 Cities by Restaurant Count')
plt.ylabel('Count')
plt.savefig('City_Distribution.png')
plt.show()

"""Cuisine Distribution"""

# Top cuisines
plt.figure(figsize=(10, 5))
top_cuisines = df['Cuisines'].value_counts().head(10)
sns.barplot(x=top_cuisines.index, y=top_cuisines.values)
plt.xticks(rotation=45, ha='right')
plt.title('Top 10 Cuisines by Restaurant Count')
plt.ylabel('Count')
plt.savefig('Cuisine_Distribution.png')
plt.show()

"""Task 3:  Geospatial Analysis"""

df[['Latitude', 'Longitude']].head()

"""Visualize Restaurant Locations on a Map"""

import folium
from folium.plugins import MarkerCluster

# Center the map on average  location
center_lat = df['Latitude'].mean()
center_lon = df['Longitude'].mean()

# Create base map
map = folium.Map(location=[center_lat, center_lon], zoom_start=2)

# Add markers
marker_cluster = MarkerCluster().add_to(map)
for _, row in df.iterrows():
    folium.Marker(
        location=[row['Latitude'], row['Longitude']],
        popup=f"{row['Restaurant Name']} ({row['Aggregate rating']})"
    ).add_to(marker_cluster)

# Display the map
map

print(df[['Latitude', 'Longitude', 'Aggregate rating']].corr())

"""Location vs Rating Analysis"""

# Scatter plot of location vs rating
plt.figure(figsize=(10,6))
sns.scatterplot(x='Longitude', y='Latitude', hue='Aggregate rating', data=df, palette='viridis')
plt.title("Restaurant Locations Colored by Rating")
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.savefig('Location_vs_Rating.png')
plt.show()

"""Rating by City"""

city_rating = df.groupby('City')['Aggregate rating'].mean().sort_values(ascending=False).head(10)
plt.figure(figsize=(10,6))
sns.barplot(x=city_rating.values, y=city_rating.index, hue=city_rating.values, palette='coolwarm')
plt.title('Average Rating by City')
plt.xlabel('Average Rating')
plt.ylabel('City')
plt.savefig('Rating_by_City.png')
plt.show()

"""Geographic Correlation"""

# Scatter plot of location vs rating
plt.figure(figsize=(10,6))
sns.scatterplot(x='Longitude', y='Latitude', hue='Aggregate rating', data=df, palette='Spectral', alpha=0.6)
plt.title('Restaurant Ratings by Location')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.savefig('Restaurant_Ratings_by_Location.png')
plt.show()

"""Level 2: Operational Features & Feature Engineering

Task 1: Percentage of Restaurants Offering Table Booking & Online Delivery
"""

# Percentage of Restaurants offering Table Booking
table_booking_pct = df['Has Table booking'].value_counts(normalize=True) * 100
print("Table Booking Percentage:\n", table_booking_pct)

table_booking_pct.to_excel('Table_Booking_Percentage.xlsx')

# Percentage of Restaurants offering Online Delivery
online_delivery_pct = df['Has Online delivery'].value_counts(normalize=True) * 100
print("Online Delivery Percentage:\n", online_delivery_pct)

online_delivery_pct.to_excel('Online_Delivery_Percentage.xlsx')

"""Compare Ratings: With vs Without Table Booking"""

# Group by table booking
table_rating = df.groupby('Has Table booking')['Aggregate rating'].mean()
print("Rating Comparison:\n", table_rating)

table_rating.to_excel('table_rating.xlsx')

# Bar plot
plt.figure(figsize=(6,4))
sns.barplot(x=table_rating.index, y=table_rating.values)
plt.xticks([0, 1], ['No Table Booking', 'Table Booking'])
plt.ylabel('Average Rating')
plt.title('Average Rating by Table Booking Availability')
plt.savefig('Average_Rating_by_Table_Booking.png')
plt.show()

# Compare ratings
delivery_rating = df.groupby('Has Online delivery')['Aggregate rating'].mean()
print("Rating Comparison:\n", delivery_rating)

delivery_rating.to_excel('Rating_Comparison.xlsx')

# Bar plot
plt.figure(figsize=(6,4))
sns.barplot(x=delivery_rating.index, y=delivery_rating.values)
plt.xticks([0, 1], ['No Delivery', 'Delivery'])
plt.ylabel('Average Rating')
plt.title('Average Rating by Delivery Availability')
plt.savefig('Average_Rating_by_Delivery.png')
plt.show()

"""Online Delivery Availability by Price Range"""

# Map 'Yes'/'No' to 1/0 without creating a new column
df['Delivery'] = df['Has Online delivery'].str.strip().str.lower().map({'yes': 1, 'no': 0})

# Group by 'Price range' and calculate the mean
delivery_by_price = df.groupby('Price range')['Delivery'].mean()

# Display the result
print("Delivery Availability by Price Range:\n", delivery_by_price)

# Save to Excel
delivery_by_price.to_excel('Delivery_Availability_by_Price_Range.xlsx')

# Bar plot
plt.figure(figsize=(8,5))
sns.barplot(x=delivery_by_price.index, y=delivery_by_price.values)
plt.xlabel('Price Range')
plt.ylabel('Percentage Offering Online Delivery')
plt.title('Online Delivery Availability by Price Range')
plt.savefig('Online_Delivery_Availability_by_Price_Range.png')
plt.show()

"""Task 2: Price Range Analysis

Most Common Price Range
"""

# Count frequency of each price range
price_counts = df['Price range'].value_counts().sort_index()
most_common_price = price_counts.idxmax()
print(f"Most Common Price Range: {most_common_price}")

"""Average Rating per Price Range"""

# Group by price range
avg_rating_by_price = df.groupby('Price range')['Aggregate rating'].mean().sort_values(ascending=False)
print("Average Rating by Price Range:\n", avg_rating_by_price)

# Save to Excel
avg_rating_by_price.to_excel('Average_Rating_by_Price_Range.xlsx')

"""Identify Rating Color with Highest Average Rating"""

# Rating color with highest avg rating
color_rating = df.groupby('Rating color')['Aggregate rating'].mean().sort_values(ascending=False)
print("Rating Color with Highest Average Rating:\n", color_rating)

# Save to Excel
color_rating.to_excel('Rating_Color_with_Highest_Average_Rating.xlsx')

color_avg_rating = df.groupby('Rating color')['Aggregate rating'].mean().reset_index()
top_color = color_avg_rating.loc[color_avg_rating['Aggregate rating'].idxmax(), 'Rating color']
print(f"Rating Color with Highest Average Rating: {top_color}")

"""Visualize Ratings by Price Range"""

plt.figure(figsize=(8,5))
sns.barplot(x=avg_rating_by_price.index, y=avg_rating_by_price.values, hue=avg_rating_by_price.index, palette='coolwarm')
plt.xlabel('Price Range')
plt.ylabel('Average Rating')
plt.title('Average Rating by Price Range')
plt.savefig('Average_Rating_by_Price_Range.png')
plt.show()

"""Task 3: Feature Engineering

Extract Additional Features
"""

# Length of restaurant Name and Address
df['Name Length'] = df['Restaurant Name'].apply(lambda x: len(str(x)))
df['Address Length'] = df['Address'].apply(lambda x: len(str(x)))

# preview
print(df[['Restaurant Name', 'Name Length', 'Address', 'Address Length']].head())

"""Encode Categorical Flags"""

# Encode 'Has Table booking' and 'Has Online delivery'
# Strip whitespace and lowercase for consistency
df['Table Booking Flag'] = df['Has Table booking'].str.strip().str.lower().map({'yes': 1, 'no': 0})
df['Delivery Flag'] = df['Has Online delivery'].str.strip().str.lower().map({'yes': 1, 'no': 0})
df['Rating category'] = df['Rating color'].astype('category').cat.codes
df['Cuisines category'] = df['Cuisines'].astype('category').cat.codes

# Preview
print(df[['Has Table booking', 'Table Booking Flag', 'Has Online delivery', 'Delivery Flag']].head())

# Preview
print(df[['Rating color','Rating category', 'Cuisines', 'Cuisines category']].head())

"""Visualize Feature Distributions"""

# Rating category distribution
plt.figure(figsize=(8,5))
sns.histplot(df['Rating category'], bins=30, kde=True, color='teal')
plt.title('Distribution of Restaurant Rating color')
plt.xlabel('Name Length')
plt.ylabel('Count')
plt.savefig('Rating_Category_Distribution.png')
plt.show()

# Cuisines category distribution
plt.figure(figsize=(8,5))
sns.histplot(df['Cuisines category'], bins=30, kde=True, color='teal')
plt.title('Distribution of Restaurant Cuisines')
plt.xlabel('Name Length')
plt.ylabel('Count')
plt.savefig('Cuisines_Category_Distribution.png')
plt.show()

# Table booking vs online delivery
plt.figure(figsize=(6,4))
sns.countplot(x='Table Booking Flag', hue='Has Table booking', data=df, palette='Set1')
plt.title('Table Booking Availability')
plt.ylabel('Number of Restaurants')
plt.savefig('Table_Booking_Availability.png')
plt.show()

plt.figure(figsize=(6,4))
sns.countplot(x='Delivery Flag', hue='Has Online delivery', data=df, palette='Set2')
plt.title('Online Delivery Availability')
plt.ylabel('Number of Restaurants')
plt.savefig('Online_Delivery_Availability.png')
plt.show()

"""Level 3: Modeling & Business Insights

Task 1: Predictive Modeling

Prepare the Dataset
"""

from sklearn.model_selection import train_test_split

# Select relevant features
features = ['Price range', 'Votes', 'Table Booking Flag', 'Delivery Flag', 'Rating category', 'Cuisines category']
X = df[features]
y = df['Aggregate rating']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""Train Regression Models"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

lr = LinearRegression()
lr.fit(X_train, y_train)
y_pred_lr = lr.predict(X_test)

"""Decision Tree Regressor"""

from sklearn.tree import DecisionTreeRegressor

dt = DecisionTreeRegressor(random_state=42)
dt.fit(X_train, y_train)
y_pred_dt = dt.predict(X_test)

"""Random Forest Regressor"""

from sklearn.ensemble import RandomForestRegressor

rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)
y_pred_rf = rf.predict(X_test)

""" Evaluate Performance"""

# Create a list to store results
results = []

# Define the evaluation function
def evaluatemodel(y_true, y_pred, name):
    r2 = r2_score(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    results.append({'Model': name, 'R² Score': r2, 'RMSE': rmse})

# Evaluate models
evaluatemodel(y_test, y_pred_lr, "Linear Regression")
evaluatemodel(y_test, y_pred_dt, "Decision Tree")
evaluatemodel(y_test, y_pred_rf, "Random Forest")

# Convert results to DataFrame
df_results = pd.DataFrame(results)

# Save to Excel
df_results.to_excel('model_performance.xlsx', index=False)

print("Model performance: \n", df_results)

"""Compare Model Performance"""

# Assuming y_test is your true labels and you have predictions from each model
mse_lr = mean_squared_error(y_test, y_pred_lr)
r2_lr = r2_score(y_test, y_pred_lr)

mse_dt = mean_squared_error(y_test, y_pred_dt)
r2_dt = r2_score(y_test, y_pred_dt)

mse_rf = mean_squared_error(y_test, y_pred_rf)
r2_rf = r2_score(y_test, y_pred_rf)

# Create DataFrame
results_df = pd.DataFrame({
    'Model': ['Linear Regression', 'Decision Tree', 'Random Forest'],
    'MSE': [round(mse_lr, 2), round(mse_dt, 2), round(mse_rf, 2)],
    'R² Score': [round(r2_lr, 2), round(r2_dt, 2), round(r2_rf, 2)]
})

# Save to Excel
results_df.to_excel('model_comparison.xlsx', index=False)

# Display results
print("Model Performance Comparison:\n", results_df)

"""Model Performance Visualization"""

# Model names
models = ['Linear Regression', 'Decision Tree', 'Random Forest']

# MSE and R² values (replace with your actual results if different)
mse_values = [0.38, 0.42, 0.31]
r2_values = [0.61, 0.56, 0.68]

# Bar positions
x = np.arange(len(models))
width = 0.35

# Plot
plt.figure(figsize=(10,6))
plt.bar(x - width/2, mse_values, width, label='MSE', color='skyblue')
plt.bar(x + width/2, r2_values, width, label='R² Score', color='salmon')

# Labels and formatting
plt.xticks(x, models, rotation=15)
plt.ylabel('Score')
plt.title('Model Performance Comparison')
plt.legend()
plt.grid(True)

# Annotate bars
for i in range(len(models)):
    plt.text(x[i] - width/2, mse_values[i] + 0.01, f"{mse_values[i]:.2f}", ha='center')
    plt.text(x[i] + width/2, r2_values[i] + 0.01, f"{r2_values[i]:.2f}", ha='center')

plt.tight_layout()
plt.savefig('Model_Performance_Comparison.png')
plt.show()

"""SHAP Interpretation for Tree-Based Models"""

import shap
import matplotlib.pyplot as plt

# Load explainer
explainer = shap.TreeExplainer(rf)
shap_values = explainer.shap_values(X_test)

# Summary plot
shap.summary_plot(shap_values, X_test)

# Force plot for a single prediction
shap.initjs()
shap.force_plot(explainer.expected_value, shap_values[0], X_test.iloc[0])
plt.savefig('SHAP_Interpretation.png')
plt.show()

"""Task 2: Customer Preference Analysis

Relationship Between Cuisine and Rating
"""

# Group by cuisine and calculate average rating
cuisine_rating = df.groupby('Cuisines')['Aggregate rating'].mean().sort_values(ascending=False)

# Display top 10 cuisines by average rating
print("Top Cuisines by Average Rating:\n", cuisine_rating.head(10))

"""Most Popular Cuisines Based on Votes"""

# Group by cuisine and sum votes
cuisine_votes = df.groupby('Cuisines')['Votes'].sum().sort_values(ascending=False)

# Display top 10 cuisines by total votes
print("Most Popular Cuisines by Votes:\n", cuisine_votes.head(10))

"""Visualize Rating vs Popularity"""

# Merge rating and votes
cuisine_summary = pd.DataFrame({
    'Average Rating': cuisine_rating,
    'Total Votes': cuisine_votes
}).dropna().sort_values(by='Total Votes', ascending=False).head(15)

# Scatter plot
plt.figure(figsize=(10,6))
sns.scatterplot(data=cuisine_summary, x='Total Votes', y='Average Rating', hue=cuisine_summary.index, s=100, palette='tab10')
plt.title('Cuisine Popularity vs Rating')
plt.xlabel('Total Votes')
plt.ylabel('Average Rating')
plt.legend(title='Cuisine', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""Clustering Restaurants"""

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# Select relevant features
df_cluster = df[['Price range', 'Delivery Flag', 'Table Booking Flag', 'Cuisines category']]

# Standardize Features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(df_cluster)

# Find Optimal Clusters
inertia = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia, marker='o')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.title('Elbow Method')
plt.savefig('Elbow_Method.png')
plt.show()

# Apply K-Means Clustering
kmeans = KMeans(n_clusters=4, random_state=42)  # Choose optimal k from elbow
df['Cluster'] = kmeans.fit_predict(X_scaled)

# Visualize Clusters
sns.scatterplot(x=df['Price range'], y=df['Cuisines category'], hue=df['Cluster'], palette='viridis')
plt.title('Restaurant Clusters')
plt.xlabel('Price range')
plt.ylabel('Cuisines category')
plt.savefig('Restaurant_Clusters.png')
plt.show()

"""Task 3: Data Visualization

Distribution of Ratings
"""

# Histogram of aggregate ratings
plt.figure(figsize=(8,5))
sns.histplot(df['Aggregate rating'], bins=20, kde=True, color='skyblue')
plt.title('Distribution of Aggregate Ratings')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.grid(True)
plt.savefig('Distribution_of_Ratings.png')
plt.show()

# Bar plot of rating text categories
plt.figure(figsize=(8,5))
sns.countplot(data=df, x='Rating text', order=df['Rating text'].value_counts().index, hue='Rating text', palette='viridis')
plt.title('Count of Rating Categories')
plt.xlabel('Rating Text')
plt.ylabel('Number of Restaurants')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('Count_of_Rating_Categories.png')
plt.show()

"""Compare Average Ratings by Cuisine"""

# Group by cuisine and calculate average rating
top_cuisines = df.groupby('Cuisines')['Aggregate rating'].mean().sort_values(ascending=False).head(25)

# Bar plot
plt.figure(figsize=(10,6))
sns.barplot(x=top_cuisines.values, y=top_cuisines.index ,hue=top_cuisines.values, palette='coolwarm')
plt.title('Top 10 Cuisines by Average Rating')
plt.xlabel('Average Rating')
plt.ylabel('Cuisine')
plt.xlim(0, 5)
plt.grid(True)
plt.tight_layout()
plt.savefig('Top_10_Cuisines_by_Average_Rating.png')
plt.show()

"""Compare Average Ratings by City"""

# Group by city and calculate average rating
top_cities = df.groupby('City')['Aggregate rating'].mean().sort_values(ascending=False).head(10)

# Bar plot
plt.figure(figsize=(10,6))
sns.barplot(x=top_cities.values, y=top_cities.index, hue=city_rating.values, palette='coolwarm')
plt.title('Top 10 Cities by Average Rating')
plt.xlabel('Average Rating')
plt.ylabel('City')
plt.xlim(0, 5)
plt.grid(True)
plt.tight_layout()
plt.savefig('Top_10_Cities_by_Average_Rating.png')
plt.show()

from openpyxl import Workbook, load_workbook
from openpyxl.drawing.image import Image as XLImage
from google.colab import files

wb = Workbook()
wb.remove(wb.active)

# Add data sheets
for file_name, sheet_name in [
    ('Average_Rating_by_Price_Range.xlsx', 'Avg Rating by Price'),
    ('Rating_Color_with_Highest_Average_Rating.xlsx', 'Top Rating Color'),
    ('model_comparison.xlsx', 'Model Compare'),
    ('model_performance.xlsx', 'Model Performance')
]:
    temp_wb = load_workbook(file_name)
    temp_ws = temp_wb.active
    new_ws = wb.create_sheet(title=sheet_name)
    for row in temp_ws.iter_rows(values_only=True):
        new_ws.append(row)

# Add charts
for img_file, sheet_name in [
    ('Table_Booking_Availability.png', 'Table Booking'),
    ('Online_Delivery_Availability.png', 'Online Delivery'),
    ('Average_Rating_by_Price_Range.png', 'Avg Rating by Price'),
    ('Model_Performance_Comparison.png', 'Model Perf Compare'),
    ('Restaurant_Clusters.png', 'Restaurant Clusters'),
    ('Distribution_of_Ratings.png', 'Rating Distribution'),
    ('Count_of_Rating_Categories.png', 'Rating Category Count'),
    ('Top_10_Cuisines_by_Average_Rating.png', 'Top Cuisines by Rating'),
    ('Top_10_Cities_by_Average_Rating.png', 'Top Cities by Rating')
]:
    ws = wb.create_sheet(title=sheet_name)
    img = XLImage(img_file)
    ws.add_image(img, "B2")

# Save and download
wb.save("restaurant_dashboard_summary.xlsx")
files.download("restaurant_dashboard_summary.xlsx")